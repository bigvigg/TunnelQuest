
- TunnelQuestWatcher
	- have it hit a "heartbeat" api endpoint every 5 minutes to let the server know it's still running, just quiet
	- display the # of bots currently feeding it
	- don't let it start sending lines until it sees "You have entered East Commonlands.".  the user might
	  have to camp or zone if they don't start the scraper until after they're already in ec.  make that super
	  clear to the user.  this is to prevent "accidents" of ppl scraping auctions from other zones 
		- but is that a problem?
			- it'll be a problem if we ever want to validate submitted data.. best to just do it this way to be safe

- make sure web app accepts unsafe characters (test this)

- aside from showing # of tunnelwatchers, show # of ppl on the hub too
	- remember there are separate hubs for chat and auction

- how AuthTokens will work:
	- all tokens are generated by the client, based on the cpu id.  user never sees the word "token" or sees the value itself.

	- user only sees a panel with either "'name' Authorized", "Politely Declined", or a box "who are you?" and a button "Request Access"

		- when app starts, it will make a call to an api endpoint "/user" with the bearer token header, which will return a response of either:
			- 401(?) Unauthorized, which means user never clicked request
			- 200 OK status containing { name: submitted_name, status: pending,approved,declined }

		- the "start logging" button will be disabled until "Authorized"

	- (client will also have a small "settings" menu with a box for the api url, saved as a persistent user config setting)


- add new nullable string column MessageToUser in auth_tokens

- replace the default vue favicon.ico
		
- figure out why "WTS aaa [link]" isn't interpreting aaa as descriptive text, and is creating an auction for it instead (ParsedChatLine.cs line 142)

- create new table auction_history to contain "snapshot" data for reporting
	- columns:
		PK long auction_history_id (identity)
		string server_code
		string item_name (NOT FK)
		string player_name
		(ALL the same columns as auction table)
		 
	- in AuctionLogic, remove the code that creates a new auction after X hours.  instead, add code to create a new auction_history record
	  (totally separate from the auctions table) every X hours.  this way, we don't have to worry about removing logical duplicate auctions
	  in the UI every X hours.

		** re-use the same existing logic that was used to determine when to create a new auction or update the existing auction,
		   and do the EXACT same thing with the existing history record: either update it or create a new one.

- make it auto-retry connect on failure (try all kinds of failure)

- stickyheader disco message fade transition not working?

- horizontal scrollbar in smallest width (because of the auction padding?)

** test to make sure people can't mess up the page by typing a really long string or something

- take automatic timers off both spell AND item repos

- new view called AuctionHouseView
	- single column (even on widescreen) infinite scrolling list of auctions
		- each list item will be two spans: one with timestamp/name/wtbwts, and one with itemName/price
			- on widescreens where there's enough room, both spans will display side-by-side to form grids; set top and bottom margins to 0, etc
			- if NOT enough space, it will break between the two divs and put one below the other (add a little margin between rows now)

- refactor SiteHeader
	- no global SiteHeader; every Page has its own custom SiteHeader in its code
	- add a slot to SiteHeader for each page to pass in custom links / controls / etc, as well as LivePage to pass in its disconnected message

- create separate hubs for chat_feed and auction_feed
	- WHY? because it's a waste of data for ppl who only want to watch chat, and don't need all the extra auction overhead

	- continue using ChatLinesAndAuctions structure
		* set Auctions = null in the chat feed and chat queries


- remember which view they went to last time in client storage, and automatically go back there again on default load
	- they can still navigate back to main menu with breadcrumb


- build in client-side check to remember the last downward scroll params, and not to repeat the same downward scroll query twice in a row




