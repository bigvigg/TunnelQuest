{"remainingRequest":"C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\ts-loader\\index.js??ref--12-2!C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\src\\classes\\SlidingList.ts","dependencies":[{"path":"C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\src\\classes\\SlidingList.ts","mtime":1550445723230},{"path":"C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\ts-loader\\index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import Vue from \"vue\";\r\n// Simple helper class to represent a fixed-size list of objects with ids that automatically trims\r\n// its earliest entries to maintain maxSize.  \r\n//\r\n// Also maintains a separate dictionary to reference entries directly by their id.\r\n//\r\n// (This is really only meant to be used for the master lists of ChatLines and Auctions)\r\nvar SlidingList = /** @class */ (function () {\r\n    // constructor\r\n    function SlidingList(sortFn) {\r\n        this.maxSize = 100; // set a reasonable default until we get the real setting from the server\r\n        this.dict = new Map();\r\n        this.array = new Array();\r\n        this.sortFunction = sortFn;\r\n    }\r\n    // public methods\r\n    SlidingList.prototype.add = function (newEntry) {\r\n        var existingEntry = this.dict.get(newEntry.id);\r\n        if (existingEntry) {\r\n            // there's already an existing entry for this id; replace it with the new object (at its existing index in the array)\r\n            var existingIndex = this.array.indexOf(existingEntry);\r\n            Vue.set(this.array, existingIndex, newEntry); // same as \"this.array[existingIndex] = newEntry;\", but causes the UI to update with the new values\r\n        }\r\n        else\r\n            this.array.push(newEntry);\r\n        this.dict.set(newEntry.id, newEntry);\r\n    };\r\n    SlidingList.prototype.enforceMaxSize = function () {\r\n        while (this.array.length > this.maxSize) {\r\n            var removedEntry = this.array.shift();\r\n            if (removedEntry)\r\n                this.dict.delete(removedEntry.id);\r\n        }\r\n    };\r\n    SlidingList.prototype.sort = function () {\r\n        // sort before enforcing maxSize to make sure we're always removing the entries from the start of the list\r\n        // according to the provided sorting function\r\n        this.array.sort(this.sortFunction);\r\n    };\r\n    SlidingList.prototype.remove = function (id) {\r\n        var existingEntry = this.dict.get(id);\r\n        if (existingEntry) {\r\n            this.dict.delete(id);\r\n            var existingIndex = this.array.indexOf(existingEntry);\r\n            this.array.splice(existingIndex, 1);\r\n        }\r\n    };\r\n    SlidingList.prototype.clear = function () {\r\n        while (this.array.length > 0) {\r\n            var removedEntry = this.array.pop();\r\n            if (removedEntry)\r\n                this.dict.delete(removedEntry.id);\r\n        }\r\n    };\r\n    SlidingList.prototype.consoleDump = function (name) {\r\n        console.log(name + \".consoleDump():\");\r\n        console.log(\"dict:\");\r\n        console.log(this.dict);\r\n        console.log(\"array:\");\r\n        console.log(this.array);\r\n    };\r\n    return SlidingList;\r\n}());\r\nexport default SlidingList;\r\n",{"version":3,"file":"C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\src\\classes\\SlidingList.ts","sourceRoot":"","sources":["C:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\src\\classes\\SlidingList.ts"],"names":[],"mappings":"AACA,OAAO,GAAG,MAAM,KAAK,CAAC;AAItB,kGAAkG;AAClG,8CAA8C;AAC9C,EAAE;AACF,kFAAkF;AAClF,EAAE;AACF,wFAAwF;AAExF;IAYI,cAAc;IAEd,qBAAY,MAA8B;QACtC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,CAAC,yEAAyE;QAC7F,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,EAAa,CAAC;QACjC,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,EAAK,CAAC;QAC5B,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;IAC/B,CAAC;IAGD,iBAAiB;IAEjB,yBAAG,GAAH,UAAI,QAAU;QACV,IAAI,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QAC/C,IAAI,aAAa,EAAE;YACf,qHAAqH;YACrH,IAAI,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;YACtD,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,aAAa,EAAE,QAAQ,CAAC,CAAC,CAAC,mGAAmG;SACpJ;;YAEG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE9B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IACzC,CAAC;IAED,oCAAc,GAAd;QACI,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE;YACrC,IAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;YACtC,IAAI,YAAY;gBACZ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;SACzC;IACL,CAAC;IAED,0BAAI,GAAJ;QACI,0GAA0G;QAC1G,6CAA6C;QAC7C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACvC,CAAC;IAED,4BAAM,GAAN,UAAO,EAAU;QACb,IAAI,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACtC,IAAI,aAAa,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAErB,IAAI,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;YACtD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;SACvC;IACL,CAAC;IAED,2BAAK,GAAL;QACI,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAC1B,IAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YACpC,IAAI,YAAY;gBACZ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;SACzC;IACL,CAAC;IAED,iCAAW,GAAX,UAAY,IAAY;QACpB,OAAO,CAAC,GAAG,CAAC,IAAI,GAAG,iBAAiB,CAAC,CAAC;QAEtC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACrB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEvB,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACtB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC5B,CAAC;IACL,kBAAC;AAAD,CAAC,AA9ED,IA8EC;AAED,eAAe,WAAW,CAAC","sourcesContent":["\r\nimport Vue from \"vue\";\r\nimport Idable from \"../interfaces/Idable\";\r\n\r\n\r\n// Simple helper class to represent a fixed-size list of objects with ids that automatically trims\r\n// its earliest entries to maintain maxSize.  \r\n//\r\n// Also maintains a separate dictionary to reference entries directly by their id.\r\n//\r\n// (This is really only meant to be used for the master lists of ChatLines and Auctions)\r\n\r\nclass SlidingList<T extends Idable> {\r\n\r\n    maxSize: number;\r\n\r\n    // (dictionary) : associative array used to directly reference an entry by its id\r\n    dict: Map<number, T>;\r\n\r\n    // ordered array of entries\r\n    array: Array<T>;\r\n\r\n    sortFunction: (a: T, b: T) => number;\r\n\r\n    // constructor\r\n\r\n    constructor(sortFn: (a: T, b: T) => number) {\r\n        this.maxSize = 100; // set a reasonable default until we get the real setting from the server\r\n        this.dict = new Map<number, T>();\r\n        this.array = new Array<T>();\r\n        this.sortFunction = sortFn;\r\n    }\r\n\r\n\r\n    // public methods\r\n\r\n    add(newEntry:T) {\r\n        let existingEntry = this.dict.get(newEntry.id);\r\n        if (existingEntry) {\r\n            // there's already an existing entry for this id; replace it with the new object (at its existing index in the array)\r\n            let existingIndex = this.array.indexOf(existingEntry);\r\n            Vue.set(this.array, existingIndex, newEntry); // same as \"this.array[existingIndex] = newEntry;\", but causes the UI to update with the new values\r\n        }\r\n        else\r\n            this.array.push(newEntry);\r\n\r\n        this.dict.set(newEntry.id, newEntry);\r\n    }\r\n\r\n    enforceMaxSize() {\r\n        while (this.array.length > this.maxSize) {\r\n            let removedEntry = this.array.shift();\r\n            if (removedEntry)\r\n                this.dict.delete(removedEntry.id);\r\n        }\r\n    }\r\n\r\n    sort() {\r\n        // sort before enforcing maxSize to make sure we're always removing the entries from the start of the list\r\n        // according to the provided sorting function\r\n        this.array.sort(this.sortFunction);\r\n    }\r\n\r\n    remove(id: number) {\r\n        let existingEntry = this.dict.get(id);\r\n        if (existingEntry) {\r\n            this.dict.delete(id);\r\n\r\n            let existingIndex = this.array.indexOf(existingEntry);\r\n            this.array.splice(existingIndex, 1);\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        while (this.array.length > 0) {\r\n            let removedEntry = this.array.pop();\r\n            if (removedEntry)\r\n                this.dict.delete(removedEntry.id);\r\n        }\r\n    }\r\n\r\n    consoleDump(name: string) {\r\n        console.log(name + \".consoleDump():\");\r\n\r\n        console.log(\"dict:\");\r\n        console.log(this.dict);\r\n\r\n        console.log(\"array:\");\r\n        console.log(this.array);\r\n    }\r\n}\r\n\r\nexport default SlidingList;"]}]}