{"remainingRequest":"c:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!c:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\src\\components\\ChatLineView.vue?vue&type=script&lang=ts&","dependencies":[{"path":"c:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\src\\components\\ChatLineView.vue","mtime":1553130341162},{"path":"c:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\ts-loader\\index.js","mtime":1545640398000},{"path":"c:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"c:\\Users\\joe\\source\\repos\\TunnelQuest\\TunnelQuest.Web\\SPA\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport Vue from \"vue\";\n\nimport ChatLine from \"../interfaces/ChatLine\";\n\nimport TQGlobals from \"../classes/TQGlobals\";\n\nimport IfDebug from \"./IfDebug.vue\";\nimport TimeStamp from \"./TimeStamp.vue\";\nimport PriceDeviationView from \"./PriceDeviationView.vue\";\n\nexport default Vue.extend({\n    props: {\n        chatLine: {\n            type: Object as () => ChatLine,\n            required: true\n        },\n        showTimestamp: {\n            type: Boolean,\n            required: true\n        },\n        itemNameLinks: {\n            type: Boolean,\n            required: true\n        },\n        itemNameToHighlight: {\n            type: String,\n            required: false\n        },\n        cssClass: {\n            type: String,\n            required: false\n        }\n    },\n    watch: {\n        chatLine: function (newValue, oldValue) {\n            this.rebuildText();\n        }\n    },\n    mounted: function () {\n        this.rebuildText();\n    },\n    methods: {\n\n        rebuildText: function () {\n            let textSpan = this.$el.querySelector(\".tqChatLineView_PlayerText\") as HTMLSpanElement;\n\n            // remove whatever text we built in there last time\n            while (textSpan.lastChild) {\n                textSpan.removeChild(textSpan.lastChild);\n            }\n\n            textSpan.appendChild(document.createTextNode(\"'\"));\n\n            let indexedItemNames = new Array<string>(); // used when adding PriceDeviationComponents\n            let unparsedText = this.chatLine.text;\n            let textSoFar = \"\"\n            let nextTokenIndex = 0;\n            while (unparsedText.length > 0) {\n\n                if (unparsedText.substring(0, TQGlobals.settings.chatToken.length) === TQGlobals.settings.chatToken) {\n                    // the next word is a special data token\n\n                    // create a text span for the player-typed words we've found up to this point in the loop\n                    let playerTextSpan = document.createElement(\"span\") as HTMLSpanElement;\n                    playerTextSpan.innerHTML = this.htmlEncode(textSoFar);\n                    textSpan.appendChild(playerTextSpan);\n                    textSoFar = \"\"; // reset textSoFar for the next iteration after the token\n\n                    let token = this.chatLine.tokens[nextTokenIndex];\n                    nextTokenIndex++;\n\n                    if (token.type == \"ITEM\") {\n                        // item name token\n\n                        let isKnownItem = (token.properties[\"isKnown\"] == \"1\");\n                        let itemName = token.properties[\"itemName\"];\n                        let text = token.properties[\"text\"];\n                        let aliasedItemName = TQGlobals.resolveItemAlias(itemName);\n                        let urlEncodedAliasedItemName = encodeURIComponent(aliasedItemName);\n\n                        indexedItemNames.push(itemName);\n\n                        if (this.itemNameLinks) {\n                            // make the item name a clickable link\n                            let linkElem = document.createElement(\"a\") as HTMLAnchorElement;\n\n                            linkElem.classList.add(isKnownItem ? \"tqKnownItemLink\" : \"tqUnknownItemLink\");\n                            if (this.itemNameToHighlight == itemName)\n                                linkElem.classList.add(\"tqHighlightedItemLink\");\n\n                            linkElem.href = \"/item/\" + urlEncodedAliasedItemName;\n                            let thisComponent = this;\n                            linkElem.addEventListener(\"click\", function (e) {\n                                e.preventDefault();\n                                thisComponent.$router.push(\"/item/\" + urlEncodedAliasedItemName);\n                            });\n                            linkElem.text = text;\n                            textSpan.appendChild(linkElem);\n                        }\n                        else if (this.itemNameToHighlight == itemName) {\n                            // highlight the item name without making it a clickable link\n                            let spanElem = document.createElement(\"span\") as HTMLSpanElement;\n                            spanElem.classList.add(isKnownItem ? \"tqKnownItemLink\" : \"tqUnknownItemLink\");\n                            spanElem.innerHTML = this.htmlEncode(text);\n                            textSpan.appendChild(spanElem);\n                        }\n                        else {\n                            textSoFar += text;\n                        }\n\n                    }\n                    else if (token.type == \"PRICE\") {\n                        // price token\n\n                        // stub\n                        if (!token.properties[\"items\"]) {\n                            console.log(\"STUB!!!\");\n                            console.log(this.chatLine);\n                        }\n\n                        let isBuying = (token.properties[\"isBuying\"] == \"1\");\n                        let price = parseInt(token.properties[\"price\"]);\n                        let itemIndexes = token.properties[\"items\"].split(',');\n                        let playerTypedPriceText = token.properties[\"text\"];\n\n                        // render the text that the player actually typed in chat\n                        let priceElem = document.createElement(\"span\") as HTMLSpanElement;\n                        priceElem.innerHTML = this.htmlEncode(playerTypedPriceText);\n                        textSpan.appendChild(priceElem);\n\n                        // now create a PriceDeviationView for each item associated with this price\n                        for (let itemNameIndexString of itemIndexes) {\n                            let itemName = indexedItemNames[parseInt(itemNameIndexString)];\n                            let priceDeviationElem = document.createElement(\"span\") as HTMLSpanElement;\n                            textSpan.appendChild(priceDeviationElem);\n                            let priceDeviationView = new PriceDeviationView({\n                                propsData: {\n                                    itemName: TQGlobals.resolveItemAlias(itemName),\n                                    price: price,\n                                    isBuying: isBuying\n                                }\n                            });\n                            priceDeviationView.$mount(priceDeviationElem);\n                        }\n                    }\n                    else {\n                        // unrecognized token\n                        throw new Error(\"Unrecognized chat token type: \" + token.type);\n                    }\n\n                    // update unparsedText\n                    let nextIndex = TQGlobals.settings.chatToken.length;\n                    if (nextIndex < unparsedText.length)\n                        unparsedText = unparsedText.substring(nextIndex);\n                    else\n                        unparsedText = \"\";\n                }\n                else {\n                    textSoFar += unparsedText[0];\n                    // updated unparsedText\n                    unparsedText = unparsedText.substring(1);\n                }\n                \n            }\n\n            if (textSoFar != \"\") {\n                let playerTextSpan = document.createElement(\"span\") as HTMLSpanElement;\n                playerTextSpan.innerHTML = this.htmlEncode(textSoFar);\n                textSpan.appendChild(playerTextSpan);\n            }\n\n            textSpan.appendChild(document.createTextNode(\"'\"));\n        },\n\n        htmlEncode: function (str: string) {\n            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/ /g, '&nbsp;');\n        }\n    },\n    components: {\n        IfDebug,\n        TimeStamp\n    }\n});\n",{"version":3,"sources":["ChatLineView.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgFA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ChatLineView.vue","sourceRoot":"src\\components","sourcesContent":["\r\n<style>\r\n\r\n    .tqChatLineId {\r\n        color: #08ff68;\r\n    }\r\n\r\n    .tqChatLineView_PlayerName {\r\n        font-style: italic;\r\n    }\r\n\r\n    .tqChatLineView_auctions {\r\n        font-style: italic;\r\n    }\r\n\r\n    .tqChatLineView_PlayerText {\r\n    }\r\n\r\n    .tqKnownItemLink {\r\n        color: #e049ff;\r\n        text-decoration: none;\r\n    }\r\n\r\n    .tqUnknownItemLink {\r\n        color: #f7d8ff;\r\n        text-decoration: none;\r\n    }\r\n\r\n    .tqHighlightedItemLink {\r\n        font-weight: bold;\r\n    }\r\n\r\n    .tqChatLineTimeStamp {\r\n        font-family: Courier New, Courier, monospace;\r\n        color: #c9c9c9;\r\n        font-size: 0.8em;\r\n    }\r\n\r\n    @media screen and (min-width: 992px) {\r\n        /* start of desktop styles */\r\n        .tqChatLineTimeStamp {\r\n            margin-right: 7px;\r\n        }\r\n    }\r\n    @media screen and (max-width: 991px) {\r\n        /* start of large tablet styles */\r\n        .tqChatLineTimeStamp {\r\n            margin-right: 6px;\r\n        }\r\n    }\r\n\r\n    @media screen and (max-width: 767px) {\r\n        /* start of medium tablet styles */\r\n        .tqChatLineTimeStamp {\r\n            margin-right: 5px;\r\n        }\r\n    }\r\n\r\n    @media screen and (max-width: 479px) {\r\n        /* start of phone styles */\r\n        .tqChatLineTimeStamp {\r\n            margin-right: 4px;\r\n        }\r\n    }\r\n\r\n</style>\r\n\r\n<template>\r\n    <span :class=\"'tqChatLineView ' + cssClass\">\r\n        <if-debug>\r\n            <span class=\"tqChatLineId\">[C{{chatLine.id}}]</span>\r\n        </if-debug>\r\n        <time-stamp v-if=\"showTimestamp\" :timeString=\"chatLine.sentAtString\" cssClass=\"tqChatLineTimeStamp\"></time-stamp>\r\n        <span class=\"tqChatLineView_PlayerName\">{{chatLine.playerName}}</span>\r\n        <span class=\"tqChatLineView_auctions\"> auctions, </span>\r\n        <span class=\"tqChatLineView_PlayerText\"></span>\r\n    </span>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n    import Vue from \"vue\";\r\n\r\n    import ChatLine from \"../interfaces/ChatLine\";\r\n\r\n    import TQGlobals from \"../classes/TQGlobals\";\r\n\r\n    import IfDebug from \"./IfDebug.vue\";\r\n    import TimeStamp from \"./TimeStamp.vue\";\r\n    import PriceDeviationView from \"./PriceDeviationView.vue\";\r\n\r\n    export default Vue.extend({\r\n        props: {\r\n            chatLine: {\r\n                type: Object as () => ChatLine,\r\n                required: true\r\n            },\r\n            showTimestamp: {\r\n                type: Boolean,\r\n                required: true\r\n            },\r\n            itemNameLinks: {\r\n                type: Boolean,\r\n                required: true\r\n            },\r\n            itemNameToHighlight: {\r\n                type: String,\r\n                required: false\r\n            },\r\n            cssClass: {\r\n                type: String,\r\n                required: false\r\n            }\r\n        },\r\n        watch: {\r\n            chatLine: function (newValue, oldValue) {\r\n                this.rebuildText();\r\n            }\r\n        },\r\n        mounted: function () {\r\n            this.rebuildText();\r\n        },\r\n        methods: {\r\n\r\n            rebuildText: function () {\r\n                let textSpan = this.$el.querySelector(\".tqChatLineView_PlayerText\") as HTMLSpanElement;\r\n\r\n                // remove whatever text we built in there last time\r\n                while (textSpan.lastChild) {\r\n                    textSpan.removeChild(textSpan.lastChild);\r\n                }\r\n\r\n                textSpan.appendChild(document.createTextNode(\"'\"));\r\n\r\n                let indexedItemNames = new Array<string>(); // used when adding PriceDeviationComponents\r\n                let unparsedText = this.chatLine.text;\r\n                let textSoFar = \"\"\r\n                let nextTokenIndex = 0;\r\n                while (unparsedText.length > 0) {\r\n\r\n                    if (unparsedText.substring(0, TQGlobals.settings.chatToken.length) === TQGlobals.settings.chatToken) {\r\n                        // the next word is a special data token\r\n\r\n                        // create a text span for the player-typed words we've found up to this point in the loop\r\n                        let playerTextSpan = document.createElement(\"span\") as HTMLSpanElement;\r\n                        playerTextSpan.innerHTML = this.htmlEncode(textSoFar);\r\n                        textSpan.appendChild(playerTextSpan);\r\n                        textSoFar = \"\"; // reset textSoFar for the next iteration after the token\r\n\r\n                        let token = this.chatLine.tokens[nextTokenIndex];\r\n                        nextTokenIndex++;\r\n\r\n                        if (token.type == \"ITEM\") {\r\n                            // item name token\r\n\r\n                            let isKnownItem = (token.properties[\"isKnown\"] == \"1\");\r\n                            let itemName = token.properties[\"itemName\"];\r\n                            let text = token.properties[\"text\"];\r\n                            let aliasedItemName = TQGlobals.resolveItemAlias(itemName);\r\n                            let urlEncodedAliasedItemName = encodeURIComponent(aliasedItemName);\r\n\r\n                            indexedItemNames.push(itemName);\r\n\r\n                            if (this.itemNameLinks) {\r\n                                // make the item name a clickable link\r\n                                let linkElem = document.createElement(\"a\") as HTMLAnchorElement;\r\n\r\n                                linkElem.classList.add(isKnownItem ? \"tqKnownItemLink\" : \"tqUnknownItemLink\");\r\n                                if (this.itemNameToHighlight == itemName)\r\n                                    linkElem.classList.add(\"tqHighlightedItemLink\");\r\n\r\n                                linkElem.href = \"/item/\" + urlEncodedAliasedItemName;\r\n                                let thisComponent = this;\r\n                                linkElem.addEventListener(\"click\", function (e) {\r\n                                    e.preventDefault();\r\n                                    thisComponent.$router.push(\"/item/\" + urlEncodedAliasedItemName);\r\n                                });\r\n                                linkElem.text = text;\r\n                                textSpan.appendChild(linkElem);\r\n                            }\r\n                            else if (this.itemNameToHighlight == itemName) {\r\n                                // highlight the item name without making it a clickable link\r\n                                let spanElem = document.createElement(\"span\") as HTMLSpanElement;\r\n                                spanElem.classList.add(isKnownItem ? \"tqKnownItemLink\" : \"tqUnknownItemLink\");\r\n                                spanElem.innerHTML = this.htmlEncode(text);\r\n                                textSpan.appendChild(spanElem);\r\n                            }\r\n                            else {\r\n                                textSoFar += text;\r\n                            }\r\n\r\n                        }\r\n                        else if (token.type == \"PRICE\") {\r\n                            // price token\r\n\r\n                            // stub\r\n                            if (!token.properties[\"items\"]) {\r\n                                console.log(\"STUB!!!\");\r\n                                console.log(this.chatLine);\r\n                            }\r\n\r\n                            let isBuying = (token.properties[\"isBuying\"] == \"1\");\r\n                            let price = parseInt(token.properties[\"price\"]);\r\n                            let itemIndexes = token.properties[\"items\"].split(',');\r\n                            let playerTypedPriceText = token.properties[\"text\"];\r\n\r\n                            // render the text that the player actually typed in chat\r\n                            let priceElem = document.createElement(\"span\") as HTMLSpanElement;\r\n                            priceElem.innerHTML = this.htmlEncode(playerTypedPriceText);\r\n                            textSpan.appendChild(priceElem);\r\n\r\n                            // now create a PriceDeviationView for each item associated with this price\r\n                            for (let itemNameIndexString of itemIndexes) {\r\n                                let itemName = indexedItemNames[parseInt(itemNameIndexString)];\r\n                                let priceDeviationElem = document.createElement(\"span\") as HTMLSpanElement;\r\n                                textSpan.appendChild(priceDeviationElem);\r\n                                let priceDeviationView = new PriceDeviationView({\r\n                                    propsData: {\r\n                                        itemName: TQGlobals.resolveItemAlias(itemName),\r\n                                        price: price,\r\n                                        isBuying: isBuying\r\n                                    }\r\n                                });\r\n                                priceDeviationView.$mount(priceDeviationElem);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // unrecognized token\r\n                            throw new Error(\"Unrecognized chat token type: \" + token.type);\r\n                        }\r\n\r\n                        // update unparsedText\r\n                        let nextIndex = TQGlobals.settings.chatToken.length;\r\n                        if (nextIndex < unparsedText.length)\r\n                            unparsedText = unparsedText.substring(nextIndex);\r\n                        else\r\n                            unparsedText = \"\";\r\n                    }\r\n                    else {\r\n                        textSoFar += unparsedText[0];\r\n                        // updated unparsedText\r\n                        unparsedText = unparsedText.substring(1);\r\n                    }\r\n                    \r\n                }\r\n\r\n                if (textSoFar != \"\") {\r\n                    let playerTextSpan = document.createElement(\"span\") as HTMLSpanElement;\r\n                    playerTextSpan.innerHTML = this.htmlEncode(textSoFar);\r\n                    textSpan.appendChild(playerTextSpan);\r\n                }\r\n\r\n                textSpan.appendChild(document.createTextNode(\"'\"));\r\n            },\r\n\r\n            htmlEncode: function (str: string) {\r\n                return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/ /g, '&nbsp;');\r\n            }\r\n        },\r\n        components: {\r\n            IfDebug,\r\n            TimeStamp\r\n        }\r\n    });\r\n</script>\r\n"]}]}